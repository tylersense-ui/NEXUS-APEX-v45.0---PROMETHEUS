/**
 * â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 * â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•
 * â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 * â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘
 * â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
 * â•šâ•â•     â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•     â•šâ•â•â•šâ•â•â•â•â•â•â•   â•šâ•â•   â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•
 *                           v45.0 - "Stealing Fire From The Gods"
 * 
 * @module      managers/hacknet-manager
 * @description Gestionnaire automatique des Hacknet Nodes.
 *              Optimise les investissements avec calcul ROI et upgrades intelligentes.
 * @author      Claude (Anthropic) + tylersense-ui
 * @version     45.0 - PROMETHEUS
 * @date        2025-01-XX
 * @license     MIT
 * @requires    BitBurner v2.8.1+ (Steam)
 * 
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ”¥ PROMETHEUS ENHANCEMENTS
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * âœ“ Cache des stats de nÅ“uds (rÃ©duit appels API rÃ©pÃ©titifs)
 * âœ“ Logique d'achat avec seuil de budget minimum
 * âœ“ Sleep adaptatif (augmente quand rien Ã  faire, diminue si opportunitÃ©)
 * âœ“ Calcul ROI (Return On Investment) pour prioriser les upgrades
 * âœ“ Try/catch robuste sur toutes les opÃ©rations Hacknet
 * âœ“ MÃ©triques dÃ©taillÃ©es (revenus totaux, investissement, profit net)
 * âœ“ Mode Ã©conomique (dÃ©sactive upgrades coÃ»teuses si budget serrÃ©)
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * @usage
 *   ns.run("/managers/hacknet-manager.js");
 *   // GÃ¨re automatiquement les Hacknet Nodes en optimisant le ROI
 * 
 * @example
 *   // Avec budget minimum personnalisÃ©
 *   // Dans constants.js : CONFIG.HACKNET = { MIN_BUDGET: 100_000_000 }
 *   ns.run("/managers/hacknet-manager.js");
 */

import { CONFIG } from "/lib/constants.js";
import { Logger } from "/lib/logger.js";

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * âš™ï¸  CONFIGURATION HACKNET
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */
const HACKNET_CONFIG = {
    /** Budget minimum avant d'acheter un nÅ“ud ou upgrade (Ã©vite bankruptcy) */
    MIN_BUDGET: CONFIG.HACKNET?.MIN_BUDGET || 10_000_000,
    
    /** Nombre maximum de nÅ“uds (limite du jeu) */
    MAX_NODES: CONFIG.HACKNET?.MAX_NODES || 30,
    
    /** ROI maximum acceptable en heures (si > 24h, pas rentable court terme) */
    MAX_ROI_HOURS: CONFIG.HACKNET?.MAX_ROI_HOURS || 24,
    
    /** Check interval par dÃ©faut (2s) */
    BASE_CHECK_INTERVAL: 2000,
    
    /** Check interval en mode idle (60s - quand rien Ã  faire) */
    IDLE_CHECK_INTERVAL: 60000,
    
    /** Pourcentage maximum du budget Ã  dÃ©penser par cycle (sÃ©curitÃ©) */
    MAX_SPEND_PERCENT: 0.3 // 30% max
};

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ”§ MAIN FUNCTION
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * Boucle principale de gestion des Hacknet Nodes.
 * 
 * @param {NS} ns - Namespace BitBurner
 */
export async function main(ns) {
    ns.disableLog("ALL");
    
    const log = new Logger(ns, "HACKNET-MGR");
    
    log.success("âœ… DÃ©marrage du Hacknet Manager PROMETHEUS");
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ“Š MÃ‰TRIQUES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const metrics = {
        totalInvested: 0,
        totalRevenue: 0,
        nodesCreated: 0,
        upgradesPerformed: 0,
        cyclesCompleted: 0,
        startTime: Date.now(),
        lastActionTime: 0
    };
    
    /**
     * Cache des stats de nÅ“uds (Ã©vite appels rÃ©pÃ©tÃ©s)
     * @type {Object|null}
     */
    let nodeCache = null;
    let cacheTimestamp = 0;
    const CACHE_TTL = 5000; // 5s de cache
    
    log.info(`âš™ï¸  Configuration:`);
    log.info(`   Budget min: ${ns.formatNumber(HACKNET_CONFIG.MIN_BUDGET)}`);
    log.info(`   Max nodes: ${HACKNET_CONFIG.MAX_NODES}`);
    log.info(`   Max ROI: ${HACKNET_CONFIG.MAX_ROI_HOURS}h`);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // â™¾ï¸ BOUCLE PRINCIPALE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    let currentInterval = HACKNET_CONFIG.BASE_CHECK_INTERVAL;
    
    while (true) {
        try {
            metrics.cyclesCompleted++;
            const player = ns.getPlayer();
            const budget = player.money;
            const availableBudget = budget - HACKNET_CONFIG.MIN_BUDGET;
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸ“Š RÃ‰CUPÃ‰RATION DES STATS (avec cache)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const now = Date.now();
            
            if (!nodeCache || (now - cacheTimestamp) > CACHE_TTL) {
                try {
                    const numNodes = ns.hacknet.numNodes();
                    const nodeStats = [];
                    
                    for (let i = 0; i < numNodes; i++) {
                        nodeStats.push({
                            level: ns.hacknet.getNodeStats(i).level,
                            ram: ns.hacknet.getNodeStats(i).ram,
                            cores: ns.hacknet.getNodeStats(i).cores,
                            production: ns.hacknet.getNodeStats(i).production,
                            totalProduction: ns.hacknet.getNodeStats(i).totalProduction
                        });
                        
                        // Accumuler les revenus totaux
                        metrics.totalRevenue = Math.max(
                            metrics.totalRevenue,
                            ns.hacknet.getNodeStats(i).totalProduction
                        );
                    }
                    
                    nodeCache = {
                        numNodes: numNodes,
                        nodes: nodeStats,
                        timestamp: now
                    };
                    cacheTimestamp = now;
                    
                } catch (error) {
                    log.error(`Erreur lors de la rÃ©cupÃ©ration des stats: ${error.message}`);
                    await ns.sleep(5000);
                    continue;
                }
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸ’° VÃ‰RIFICATION BUDGET
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (availableBudget < 0) {
                // Budget insuffisant - mode idle
                if (log.debugEnabled) {
                    log.debug(`ğŸ’¸ Budget insuffisant (${ns.formatNumber(budget)})`);
                }
                
                currentInterval = HACKNET_CONFIG.IDLE_CHECK_INTERVAL;
                await ns.sleep(currentInterval);
                continue;
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸ†• ACHAT DE NOUVEAU NÅ’UD
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (nodeCache.numNodes < HACKNET_CONFIG.MAX_NODES) {
                try {
                    const newNodeCost = ns.hacknet.getPurchaseNodeCost();
                    
                    if (newNodeCost <= availableBudget && 
                        newNodeCost <= (availableBudget * HACKNET_CONFIG.MAX_SPEND_PERCENT)) {
                        
                        const nodeIndex = ns.hacknet.purchaseNode();
                        
                        if (nodeIndex !== -1) {
                            metrics.totalInvested += newNodeCost;
                            metrics.nodesCreated++;
                            metrics.lastActionTime = now;
                            
                            log.success(`âœ… Nouveau nÅ“ud achetÃ© (#${nodeIndex}) - ${ns.formatNumber(newNodeCost)}`);
                            log.info(`   Total nodes: ${nodeCache.numNodes + 1}/${HACKNET_CONFIG.MAX_NODES}`);
                            
                            // Invalider le cache
                            nodeCache = null;
                            
                            // RÃ©duire l'intervalle (plus d'opportunitÃ©s possibles)
                            currentInterval = HACKNET_CONFIG.BASE_CHECK_INTERVAL;
                            await ns.sleep(1000);
                            continue;
                        }
                    } else if (log.debugEnabled && metrics.cyclesCompleted % 20 === 0) {
                        log.debug(`ğŸ¯ Prochain nÅ“ud: ${ns.formatNumber(newNodeCost)} (en attente)`);
                    }
                } catch (error) {
                    log.error(`Erreur lors de l'achat de nÅ“ud: ${error.message}`);
                }
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // â¬†ï¸  UPGRADES DES NÅ’UDS EXISTANTS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            let bestUpgrade = null;
            let bestROI = Infinity;
            
            for (let i = 0; i < nodeCache.numNodes; i++) {
                try {
                    // CoÃ»ts des upgrades possibles
                    const levelCost = ns.hacknet.getLevelUpgradeCost(i, 1);
                    const ramCost = ns.hacknet.getRamUpgradeCost(i, 1);
                    const coreCost = ns.hacknet.getCoreUpgradeCost(i, 1);
                    
                    // Ã‰valuer chaque type d'upgrade
                    const upgrades = [
                        { type: 'level', cost: levelCost, func: () => ns.hacknet.upgradeLevel(i, 1) },
                        { type: 'ram', cost: ramCost, func: () => ns.hacknet.upgradeRam(i, 1) },
                        { type: 'core', cost: coreCost, func: () => ns.hacknet.upgradeCore(i, 1) }
                    ];
                    
                    for (const upgrade of upgrades) {
                        if (upgrade.cost > availableBudget) continue;
                        if (upgrade.cost > (availableBudget * HACKNET_CONFIG.MAX_SPEND_PERCENT)) continue;
                        if (upgrade.cost === Infinity) continue;
                        
                        // Calcul ROI approximatif (heures pour rÃ©cupÃ©rer l'investissement)
                        const currentProduction = nodeCache.nodes[i].production; // $/s
                        const productionPerHour = currentProduction * 3600;
                        const roi = productionPerHour > 0 ? upgrade.cost / productionPerHour : Infinity;
                        
                        if (roi < bestROI && roi < HACKNET_CONFIG.MAX_ROI_HOURS) {
                            bestROI = roi;
                            bestUpgrade = { nodeIndex: i, ...upgrade };
                        }
                    }
                } catch (error) {
                    log.error(`Erreur lors de l'Ã©valuation du nÅ“ud ${i}: ${error.message}`);
                }
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸ’ EXÃ‰CUTION DE LA MEILLEURE UPGRADE
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (bestUpgrade) {
                try {
                    const success = bestUpgrade.func();
                    
                    if (success) {
                        metrics.totalInvested += bestUpgrade.cost;
                        metrics.upgradesPerformed++;
                        metrics.lastActionTime = now;
                        
                        log.success(`â¬†ï¸  Node #${bestUpgrade.nodeIndex} ${bestUpgrade.type} upgraded`);
                        log.info(`   CoÃ»t: ${ns.formatNumber(bestUpgrade.cost)} | ROI: ${bestROI.toFixed(1)}h`);
                        
                        // Invalider le cache
                        nodeCache = null;
                        
                        // RÃ©duire l'intervalle
                        currentInterval = HACKNET_CONFIG.BASE_CHECK_INTERVAL;
                        await ns.sleep(500);
                        continue;
                    }
                } catch (error) {
                    log.error(`Erreur lors de l'upgrade: ${error.message}`);
                }
            } else {
                // Aucune upgrade rentable trouvÃ©e - mode idle
                if (log.debugEnabled && metrics.cyclesCompleted % 30 === 0) {
                    log.debug(`â¸ï¸  Aucune upgrade rentable dÃ©tectÃ©e (ROI > ${HACKNET_CONFIG.MAX_ROI_HOURS}h)`);
                }
                
                currentInterval = HACKNET_CONFIG.IDLE_CHECK_INTERVAL;
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸ“Š RAPPORT PÃ‰RIODIQUE (toutes les 50 cycles)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (metrics.cyclesCompleted % 50 === 0) {
                const uptime = now - metrics.startTime;
                const uptimeMin = Math.floor(uptime / 60000);
                const profit = metrics.totalRevenue - metrics.totalInvested;
                const profitPercent = metrics.totalInvested > 0 
                    ? (profit / metrics.totalInvested) * 100 
                    : 0;
                
                log.info(`ğŸ“Š Stats Hacknet:`);
                log.info(`   Nodes: ${nodeCache.numNodes}/${HACKNET_CONFIG.MAX_NODES}`);
                log.info(`   Investissement: ${ns.formatNumber(metrics.totalInvested)}`);
                log.info(`   Revenus: ${ns.formatNumber(metrics.totalRevenue)}`);
                log.info(`   Profit: ${ns.formatNumber(profit)} (${profitPercent > 0 ? '+' : ''}${profitPercent.toFixed(1)}%)`);
                log.info(`   Upgrades: ${metrics.upgradesPerformed} | Uptime: ${uptimeMin}min`);
            }
            
        } catch (error) {
            log.error(`Erreur dans la boucle principale: ${error.message}`);
            currentInterval = HACKNET_CONFIG.IDLE_CHECK_INTERVAL;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // â±ï¸  SLEEP ADAPTATIF
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        await ns.sleep(currentInterval);
    }
}
