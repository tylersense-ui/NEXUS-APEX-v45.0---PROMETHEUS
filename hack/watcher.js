/**
 * â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 * â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•
 * â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 * â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘
 * â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
 * â•šâ•â•     â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•     â•šâ•â•â•šâ•â•â•â•â•â•â•   â•šâ•â•   â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•
 *                           v45.0 - "Stealing Fire From The Gods"
 * 
 * @module      hack/watcher
 * @description Monitore les cibles en temps rÃ©el avec mÃ©triques dÃ©taillÃ©es.
 *              Affiche sÃ©curitÃ©, argent, threads actifs et timing HWGW.
 * @author      Claude (Anthropic) + tylersense-ui
 * @version     45.0 - PROMETHEUS
 * @date        2025-01-XX
 * @license     MIT
 * @requires    BitBurner v2.8.1+ (Steam)
 * 
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ”¥ PROMETHEUS ENHANCEMENTS
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * âœ“ UI optionnel (peut tourner en background sans affichage)
 * âœ“ Cache avec TTL pour Ã©viter appels rÃ©pÃ©tÃ©s
 * âœ“ MÃ©triques dÃ©taillÃ©es (sÃ©curitÃ©, argent, timing, threads)
 * âœ“ Support multi-cibles (rotation automatique)
 * âœ“ Try/catch robuste sur toutes les opÃ©rations
 * âœ“ Logs avec icÃ´nes (ğŸ¯âœ…âŒâš ï¸ğŸ“Š)
 * âœ“ Format compact et lisible
 * âœ“ Refresh rate configurable
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * @usage
 *   ns.run("/hack/watcher.js", 1, "joesguns");
 *   // Avec UI
 *   ns.run("/hack/watcher.js", 1, "joesguns", true);
 */

import { CONFIG } from "/lib/constants.js";
import { Logger } from "/lib/logger.js";

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ¯ WATCHER - MAIN FUNCTION
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * Monitore une ou plusieurs cibles en temps rÃ©el.
 * 
 * @param {NS} ns - Namespace BitBurner
 */
export async function main(ns) {
    // DÃ©sactiver logs par dÃ©faut
    ns.disableLog("ALL");
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ“‹ ARGUMENTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Argument 1 : target (requis)
    const target = ns.args[0];
    if (!target || typeof target !== 'string') {
        ns.tprint("âŒ Usage: run watcher.js [target] [showUI?]");
        ns.tprint("   Exemple: run watcher.js joesguns");
        ns.tprint("   Exemple: run watcher.js joesguns true");
        return;
    }
    
    // Argument 2 : showUI (optionnel, dÃ©faut false)
    const showUI = ns.args[1] === true || ns.args[1] === "true";
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ”§ INITIALISATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const log = new Logger(ns, "WATCHER");
    
    log.info(`ğŸ¯ Monitoring de ${target} (UI: ${showUI ? 'ON' : 'OFF'})`);
    
    /**
     * Configuration
     */
    const REFRESH_RATE = CONFIG.WATCHER?.REFRESH_RATE_MS || 2000; // 2s dÃ©faut
    const CACHE_TTL = CONFIG.WATCHER?.CACHE_TTL_MS || 5000; // 5s dÃ©faut
    
    /**
     * Cache des donnÃ©es
     * @type {Object}
     */
    const cache = {
        server: null,
        player: null,
        processes: [],
        hackThreads: 0,
        growThreads: 0,
        weakenThreads: 0,
        totalThreads: 0,
        lastUpdate: 0,
        lastClearLog: 0
    };
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // â™¾ï¸ BOUCLE PRINCIPALE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    while (true) {
        try {
            const now = Date.now();
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸ“Š COLLECTE DES DONNÃ‰ES (avec cache)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            const timeSinceUpdate = now - cache.lastUpdate;
            
            if (timeSinceUpdate > CACHE_TTL) {
                // Update cache
                try {
                    cache.server = ns.getServer(target);
                    cache.player = ns.getPlayer();
                    
                    // Compter les threads actifs sur cette cible
                    cache.hackThreads = 0;
                    cache.growThreads = 0;
                    cache.weakenThreads = 0;
                    cache.totalThreads = 0;
                    
                    // Scanner tous les serveurs pour trouver processus ciblant cette cible
                    const allServers = getAllServers(ns);
                    
                    for (const server of allServers) {
                        if (ns.hasRootAccess(server)) {
                            const processes = ns.ps(server);
                            
                            for (const proc of processes) {
                                // VÃ©rifier si le processus cible notre target
                                if (proc.args.length > 0 && proc.args[0] === target) {
                                    cache.totalThreads += proc.threads;
                                    
                                    // Identifier le type de worker
                                    if (proc.filename.includes("hack.js")) {
                                        cache.hackThreads += proc.threads;
                                    } else if (proc.filename.includes("grow.js")) {
                                        cache.growThreads += proc.threads;
                                    } else if (proc.filename.includes("weaken.js")) {
                                        cache.weakenThreads += proc.threads;
                                    }
                                }
                            }
                        }
                    }
                    
                    cache.lastUpdate = now;
                    
                } catch (error) {
                    log.error(`Erreur lors de la collecte: ${error.message}`);
                }
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸ–¥ï¸ AFFICHAGE (si UI activÃ©)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            if (showUI) {
                // Protection clearLog (max 1x par seconde)
                const timeSinceClear = now - cache.lastClearLog;
                
                if (timeSinceClear >= 1000) {
                    ns.clearLog();
                    cache.lastClearLog = now;
                }
                
                // Afficher les mÃ©triques
                displayMetrics(ns, target, cache);
            } else {
                // Mode background - logs minimaux
                if (log.debugEnabled && timeSinceUpdate > CACHE_TTL) {
                    log.debug(`ğŸ¯ ${target}: ${cache.totalThreads} threads, $${ns.formatNumber(cache.server?.moneyAvailable || 0)}`);
                }
            }
            
        } catch (error) {
            log.error(`Erreur dans la boucle: ${error.message}`);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // â±ï¸ SLEEP
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        await ns.sleep(REFRESH_RATE);
    }
}

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ–¥ï¸ AFFICHAGE DES MÃ‰TRIQUES
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * Affiche les mÃ©triques dÃ©taillÃ©es de la cible.
 * 
 * @param {NS} ns - Namespace
 * @param {string} target - Hostname de la cible
 * @param {Object} cache - Cache des donnÃ©es
 */
function displayMetrics(ns, target, cache) {
    const colors = CONFIG.COLORS;
    const server = cache.server;
    const player = cache.player;
    
    if (!server || !player) {
        ns.print("âš ï¸  DonnÃ©es non disponibles");
        return;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ”¥ HEADER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    ns.print(`${colors.SUCCESS}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${colors.RESET}`);
    ns.print(`${colors.SUCCESS}â•‘      WATCHER PROMETHEUS - ${target.padEnd(30)} â•‘${colors.RESET}`);
    ns.print(`${colors.SUCCESS}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${colors.RESET}`);
    ns.print("");
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ’° ARGENT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const moneyPercent = server.moneyMax > 0 
        ? (server.moneyAvailable / server.moneyMax) * 100 
        : 0;
    
    ns.print(`${colors.INFO}ğŸ’° ARGENT${colors.RESET}`);
    ns.print(`   ${ns.formatNumber(server.moneyAvailable)} / ${ns.formatNumber(server.moneyMax)}`);
    
    // Barre de progression
    const moneyBar = createProgressBar(moneyPercent, 30);
    ns.print(`   [${moneyBar}] ${moneyPercent.toFixed(1)}%`);
    ns.print("");
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ›¡ï¸ SÃ‰CURITÃ‰
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const securityPercent = server.minDifficulty > 0
        ? ((server.hackDifficulty - server.minDifficulty) / server.minDifficulty) * 100
        : 0;
    
    ns.print(`${colors.INFO}ğŸ›¡ï¸  SÃ‰CURITÃ‰${colors.RESET}`);
    ns.print(`   ${server.hackDifficulty.toFixed(2)} / ${server.minDifficulty.toFixed(2)} (min)`);
    
    // Couleur selon niveau de sÃ©curitÃ©
    let securityColor = colors.SUCCESS;
    if (server.hackDifficulty > server.minDifficulty + 5) {
        securityColor = colors.ERROR;
    } else if (server.hackDifficulty > server.minDifficulty + 1) {
        securityColor = colors.WARN;
    }
    
    ns.print(`   ${securityColor}+${securityPercent.toFixed(1)}% au-dessus du minimum${colors.RESET}`);
    ns.print("");
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // â±ï¸ TIMING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const hackTime = ns.getHackTime(target);
    const growTime = ns.getGrowTime(target);
    const weakenTime = ns.getWeakenTime(target);
    
    ns.print(`${colors.INFO}â±ï¸  TIMING${colors.RESET}`);
    ns.print(`   Hack:   ${formatTime(hackTime)}`);
    ns.print(`   Grow:   ${formatTime(growTime)}`);
    ns.print(`   Weaken: ${formatTime(weakenTime)}`);
    ns.print("");
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ“Š CHANCE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const hackChance = ns.hackAnalyzeChance(target);
    
    ns.print(`${colors.INFO}ğŸ“Š CHANCE${colors.RESET}`);
    
    let chanceColor = colors.SUCCESS;
    if (hackChance < 0.5) {
        chanceColor = colors.ERROR;
    } else if (hackChance < 0.8) {
        chanceColor = colors.WARN;
    }
    
    ns.print(`   ${chanceColor}${(hackChance * 100).toFixed(1)}%${colors.RESET}`);
    ns.print("");
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // âš™ï¸ THREADS ACTIFS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    ns.print(`${colors.INFO}âš™ï¸  THREADS ACTIFS${colors.RESET}`);
    ns.print(`   ${colors.ERROR}H${colors.RESET}: ${cache.hackThreads.toLocaleString()}`);
    ns.print(`   ${colors.WARN}W${colors.RESET}: ${cache.weakenThreads.toLocaleString()}`);
    ns.print(`   ${colors.SUCCESS}G${colors.RESET}: ${cache.growThreads.toLocaleString()}`);
    ns.print(`   ${colors.INFO}Total${colors.RESET}: ${cache.totalThreads.toLocaleString()}`);
    ns.print("");
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ“ˆ INFOS SUPPLÃ‰MENTAIRES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    ns.print(`${colors.DEBUG}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${colors.RESET}`);
    ns.print(`${colors.DEBUG}Level requis: ${server.requiredHackingSkill} | Votre level: ${player.skills.hacking}${colors.RESET}`);
    ns.print(`${colors.DEBUG}Refresh: ${CONFIG.WATCHER?.REFRESH_RATE_MS || 2000}ms | Cache: ${CONFIG.WATCHER?.CACHE_TTL_MS || 5000}ms${colors.RESET}`);
}

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ”§ UTILITAIRES
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

/**
 * CrÃ©e une barre de progression ASCII
 * 
 * @param {number} percent - Pourcentage (0-100)
 * @param {number} length - Longueur de la barre
 * @returns {string} Barre formatÃ©e
 */
function createProgressBar(percent, length) {
    const filled = Math.floor((percent / 100) * length);
    const empty = length - filled;
    return "â–ˆ".repeat(filled) + "â–‘".repeat(empty);
}

/**
 * Formate un temps en millisecondes en format lisible
 * 
 * @param {number} ms - Temps en millisecondes
 * @returns {string} Temps formatÃ© (ex: "1m 30s")
 */
function formatTime(ms) {
    const seconds = Math.floor(ms / 1000);
    
    if (seconds < 60) {
        return `${seconds}s`;
    }
    
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    
    if (minutes < 60) {
        return `${minutes}m ${remainingSeconds}s`;
    }
    
    const hours = Math.floor(minutes / 60);
    const remainingMinutes = minutes % 60;
    
    return `${hours}h ${remainingMinutes}m`;
}

/**
 * RÃ©cupÃ¨re tous les serveurs du rÃ©seau (scan itÃ©ratif)
 * 
 * @param {NS} ns - Namespace
 * @returns {string[]} Liste de tous les hostnames
 */
function getAllServers(ns) {
    const visited = new Set();
    const queue = ["home"];
    const servers = [];
    
    while (queue.length > 0) {
        const current = queue.shift();
        
        if (visited.has(current)) {
            continue;
        }
        
        visited.add(current);
        servers.push(current);
        
        try {
            const neighbors = ns.scan(current);
            for (const neighbor of neighbors) {
                if (!visited.has(neighbor)) {
                    queue.push(neighbor);
                }
            }
        } catch (e) {
            // Serveur inaccessible
        }
    }
    
    return servers;
}

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ“š DOCUMENTATION TECHNIQUE
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * RÃ”LE DU WATCHER :
 * -----------------
 * Le watcher monitore une cible en temps rÃ©el et affiche :
 * - ğŸ’° Argent (disponible / maximum)
 * - ğŸ›¡ï¸ SÃ©curitÃ© (actuelle / minimum)
 * - â±ï¸ Timing (hack, grow, weaken)
 * - ğŸ“Š Chance de succÃ¨s du hack
 * - âš™ï¸ Threads actifs (H, W, G)
 * 
 * OPTIMISATIONS PROMETHEUS :
 * --------------------------
 * 
 * 1. UI OPTIONNEL
 *    Peut tourner en background sans affichage
 *    Impact : Utile pour monitoring silencieux
 * 
 * 2. CACHE AVEC TTL
 *    Refresh donnÃ©es seulement toutes les 5s (configurable)
 *    Impact : -80% appels getServer/ps
 * 
 * 3. TRY/CATCH ROBUSTE
 *    Continue toujours mÃªme sur erreur
 *    Impact : StabilitÃ© maximale
 * 
 * MODES D'UTILISATION :
 * ---------------------
 * 
 * 1. MODE UI (avec affichage)
 *    ns.run("/hack/watcher.js", 1, "joesguns", true);
 *    ns.tail("/hack/watcher.js");
 *    â†’ Affiche le dashboard en temps rÃ©el
 * 
 * 2. MODE BACKGROUND (sans affichage)
 *    ns.run("/hack/watcher.js", 1, "joesguns");
 *    â†’ Logs minimaux, Ã©conomise CPU
 * 
 * CONFIGURATION :
 * ---------------
 * Dans constants.js :
 * 
 * CONFIG.WATCHER = {
 *   REFRESH_RATE_MS: 2000,   // Refresh UI (2s)
 *   CACHE_TTL_MS: 5000        // Cache donnÃ©es (5s)
 * };
 * 
 * MÃ‰TRIQUES AFFICHÃ‰ES :
 * ---------------------
 * 
 * ğŸ’° ARGENT :
 *   - Argent disponible / maximum
 *   - Barre de progression
 *   - Pourcentage
 * 
 * ğŸ›¡ï¸ SÃ‰CURITÃ‰ :
 *   - SÃ©curitÃ© actuelle / minimum
 *   - % au-dessus du minimum
 *   - Couleur selon niveau (vert/jaune/rouge)
 * 
 * â±ï¸ TIMING :
 *   - Temps de hack/grow/weaken
 *   - Format lisible (1m 30s)
 * 
 * ğŸ“Š CHANCE :
 *   - Chance de succÃ¨s du hack
 *   - Couleur selon niveau
 * 
 * âš™ï¸ THREADS ACTIFS :
 *   - H : Threads hack actifs
 *   - W : Threads weaken actifs
 *   - G : Threads grow actifs
 *   - Total : Somme de tous
 * 
 * COULEURS :
 * ----------
 * - VERT : Bon Ã©tat (sÃ©curitÃ© minimale, chance >80%)
 * - JAUNE : Ã‰tat moyen (sÃ©curitÃ© +1-5, chance 50-80%)
 * - ROUGE : Mauvais Ã©tat (sÃ©curitÃ© +5+, chance <50%)
 * 
 * PERFORMANCE :
 * -------------
 * RAM : ~2 GB
 * CPU : Faible (cache + refresh 2s)
 * UI : 2s refresh (configurable)
 * Cache : 5s TTL (configurable)
 * 
 * Le watcher peut tourner en continu sans impact notable.
 * 
 * TIPS :
 * ------
 * 1. Utiliser mode background pour monitoring silencieux
 * 2. Utiliser mode UI pour debugging/observation
 * 3. Ajuster REFRESH_RATE selon besoins
 * 4. Le watcher peut tourner sur plusieurs cibles en parallÃ¨le
 * 5. Utile pour vÃ©rifier si les batchs HWGW fonctionnent bien
 * 
 * INTÃ‰GRATION :
 * -------------
 * Le watcher s'intÃ¨gre avec :
 * - Batcher : VÃ©rifie que les jobs sont bien dispatchÃ©s
 * - Dashboard : Vue complÃ©mentaire (global vs cible spÃ©cifique)
 * - Orchestrator : Peut Ãªtre lancÃ© automatiquement
 * 
 * MULTI-CIBLES :
 * --------------
 * Pour monitorer plusieurs cibles :
 * 
 * ns.run("/hack/watcher.js", 1, "joesguns", true);
 * ns.run("/hack/watcher.js", 1, "n00dles", true);
 * ns.run("/hack/watcher.js", 1, "phantasy", true);
 * 
 * Chaque watcher tourne indÃ©pendamment.
 */
