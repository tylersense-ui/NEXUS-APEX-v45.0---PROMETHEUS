/**
 * â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 * â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•
 * â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 * â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘
 * â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
 * â•šâ•â•     â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•     â•šâ•â•â•šâ•â•â•â•â•â•â•   â•šâ•â•   â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•
 *                           v45.0 - "Stealing Fire From The Gods"
 * 
 * @module      hack/workers/share
 * @description Worker de share - Partage la puissance de calcul avec des factions.
 *              Augmente le pouvoir de faction et donne des bonus passifs.
 * @author      Claude (Anthropic) + tylersense-ui
 * @version     45.0 - PROMETHEUS
 * @date        2025-01-XX
 * @license     MIT
 * @requires    BitBurner v2.8.1+ (Steam)
 * @ram         4.00 GB (pour 1 thread)
 * 
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ”¥ PROMETHEUS ENHANCEMENTS
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * âœ“ Validation du dÃ©lai optionnel
 * âœ“ Try/catch robuste autour de ns.share()
 * âœ“ Gestion d'erreur avec logging dÃ©taillÃ©
 * âœ“ Logs avec icÃ´nes (ğŸ¤âœ…âŒâ±ï¸)
 * âœ“ Support du dÃ©lai avant dÃ©marrage
 * âœ“ Boucle infinie automatique (share est bloquant)
 * âœ“ Protection contre arguments invalides
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * @usage
 *   ns.exec("/hack/workers/share.js", "host", threads, delay);
 * 
 * @arguments
 *   delay (number) - DÃ©lai en ms avant de dÃ©marrer (dÃ©faut: 0)
 * 
 * @example
 *   // Share immÃ©diat (boucle infinie)
 *   ns.exec("/hack/workers/share.js", "pserv-0", 100, 0);
 * 
 * @example
 *   // Share avec dÃ©lai
 *   ns.exec("/hack/workers/share.js", "pserv-0", 50, 5000);
 *   // Attend 5 secondes avant de commencer Ã  partager
 * 
 * @returns
 *   Ne retourne jamais (boucle infinie bloquante)
 */

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ¯ WORKER SHARE - MAIN FUNCTION
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ExÃ©cute une opÃ©ration de share en boucle infinie aprÃ¨s un dÃ©lai optionnel.
 * 
 * Le share partage la puissance de calcul avec des factions.
 * Augmente le pouvoir de faction et donne des bonus passifs (reputation, etc.).
 * 
 * IMPORTANT : ns.share() est une fonction BLOQUANTE qui ne se termine jamais.
 * Elle doit Ãªtre utilisÃ©e dans un script dÃ©diÃ© qui tourne en continu.
 * 
 * @param {NS} ns - Namespace BitBurner
 */
export async function main(ns) {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ“‹ VALIDATION DES ARGUMENTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Argument 1 : delay (optionnel, dÃ©faut 0)
    let delay = ns.args[0] || 0;
    if (typeof delay !== 'number' || delay < 0) {
        ns.print(`âš ï¸  [SHARE] DÃ©lai invalide (${delay}), utilisation de 0`);
        delay = 0;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // â±ï¸ DÃ‰LAI AVANT DÃ‰MARRAGE (si spÃ©cifiÃ©)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    if (delay > 0) {
        ns.print(`â±ï¸  [SHARE] Attente de ${delay}ms avant dÃ©marrage...`);
        await ns.sleep(delay);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ¤ EXÃ‰CUTION DU SHARE (BOUCLE INFINIE)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    ns.print(`âœ… [SHARE] DÃ©marrage du partage en continu...`);
    
    try {
        // ns.share() est une fonction BLOQUANTE qui ne se termine jamais
        // Elle boucle automatiquement en interne
        await ns.share();
        
        // Cette ligne ne devrait jamais Ãªtre atteinte
        ns.print(`âš ï¸  [SHARE] ns.share() s'est terminÃ© (comportement inattendu)`);
        
    } catch (error) {
        // Erreur critique (script killÃ©, etc.)
        ns.tprint(`âŒ [SHARE] Erreur critique: ${error.message}`);
    }
}

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ“š DOCUMENTATION TECHNIQUE
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * OPÃ‰RATION SHARE :
 * -----------------
 * - Partage la puissance de calcul avec des factions
 * - Augmente le pouvoir de faction du joueur
 * - Donne des bonus passifs (reputation, etc.)
 * - Utilise la RAM disponible pour des calculs distribuÃ©s
 * 
 * FONCTIONNEMENT :
 * ----------------
 * ns.share() est une fonction BLOQUANTE qui :
 * - Ne se termine jamais (boucle infinie interne)
 * - Utilise 4.00 GB de RAM par thread
 * - N'a pas besoin de cible (contrairement Ã  hack/grow/weaken)
 * - Doit tourner en continu pour avoir un effet
 * 
 * Le script continue Ã  s'exÃ©cuter jusqu'Ã  ce qu'il soit killÃ© manuellement
 * ou que le serveur soit redÃ©marrÃ©.
 * 
 * COÃ›T ET BÃ‰NÃ‰FICES :
 * -------------------
 * RAM : 4.00 GB par thread (plus cher que hack/grow/weaken)
 * 
 * BÃ©nÃ©fices :
 * - Augmente le pouvoir de faction
 * - Bonus de reputation pour certaines factions
 * - Utile quand on a de la RAM disponible mais pas de cibles intÃ©ressantes
 * - Peut Ãªtre stoppÃ©/redÃ©marrÃ© Ã  tout moment sans perte
 * 
 * Les bÃ©nÃ©fices sont proportionnels au nombre de threads utilisÃ©s.
 * Plus de threads = plus de pouvoir de faction.
 * 
 * QUAND UTILISER SHARE :
 * ----------------------
 * Utiliser share() quand :
 * - Vous avez de la RAM inutilisÃ©e
 * - Pas de cibles intÃ©ressantes Ã  hacker
 * - Vous voulez augmenter votre pouvoir de faction
 * - En early game quand les serveurs ont peu d'argent
 * 
 * NE PAS utiliser share() si :
 * - Vous avez des cibles rentables Ã  hacker (hack/grow/weaken est plus profitable)
 * - Votre RAM est limitÃ©e (share coÃ»te 4 GB/thread)
 * - Vous n'Ãªtes pas intÃ©ressÃ© par les factions
 * 
 * DIFFÃ‰RENCE AVEC HACK/GROW/WEAKEN :
 * -----------------------------------
 * Share est fondamentalement diffÃ©rent :
 * - Pas de cible (pas d'argument target)
 * - Boucle infinie (jamais terminÃ©)
 * - Plus cher en RAM (4 GB vs ~1.7 GB)
 * - Pas de retour (void)
 * - BÃ©nÃ©fice passif et continu
 * - Utile pour factions, pas pour argent
 * 
 * UTILISATION DANS LE SYSTÃˆME :
 * ------------------------------
 * Le share n'est PAS utilisÃ© dans les batchs HWGW.
 * C'est un script sÃ©parÃ© qui tourne en parallÃ¨le.
 * 
 * StratÃ©gie typique :
 * 1. Calculer la RAM nÃ©cessaire pour les batchs HWGW
 * 2. Utiliser le reste de la RAM pour share()
 * 3. Ajuster dynamiquement selon les besoins
 * 
 * Exemple :
 *   totalRam = 1000 GB
 *   ramForBatches = 800 GB (hack/grow/weaken)
 *   ramForShare = 200 GB
 *   threadsShare = Math.floor(200 / 4) = 50 threads
 * 
 * GESTION DYNAMIQUE :
 * -------------------
 * Le share peut Ãªtre stoppÃ© et redÃ©marrÃ© Ã  tout moment :
 * 
 * // Stopper tous les share
 * ns.killall("pserv-0", "/hack/workers/share.js");
 * 
 * // RedÃ©marrer avec nouvelle allocation
 * ns.exec("/hack/workers/share.js", "pserv-0", newThreads);
 * 
 * Cette flexibilitÃ© permet d'ajuster l'allocation de RAM
 * en fonction des besoins changeants du systÃ¨me.
 * 
 * ARGUMENTS DÃ‰TAILLÃ‰S :
 * ---------------------
 * delay (number, optionnel) :
 *   - DÃ©lai en millisecondes avant de commencer Ã  partager
 *   - Utile pour synchroniser le dÃ©marrage avec d'autres scripts
 *   - DÃ©faut : 0 (dÃ©marrage immÃ©diat)
 *   - Exemple : delay = 5000 â†’ attend 5s avant de partager
 * 
 * CODES DE RETOUR :
 * -----------------
 * Le share ne retourne jamais normalement.
 * Il continue jusqu'Ã  Ãªtre killÃ© manuellement.
 * 
 * Si le script se termine, c'est une anomalie (error ou comportement inattendu).
 * 
 * EXEMPLES D'UTILISATION :
 * ------------------------
 * 
 * // Share simple (dÃ©marrage immÃ©diat)
 * ns.exec("/hack/workers/share.js", "pserv-0", 50);
 * 
 * // Share avec dÃ©lai (synchronisation)
 * ns.exec("/hack/workers/share.js", "pserv-0", 100, 5000);
 * 
 * // Calculer threads disponibles pour share
 * const totalRam = ns.getServerMaxRam("pserv-0");
 * const usedRam = ns.getServerUsedRam("pserv-0");
 * const freeRam = totalRam - usedRam;
 * const threadsShare = Math.floor(freeRam / 4.0);
 * if (threadsShare > 0) {
 *     ns.exec("/hack/workers/share.js", "pserv-0", threadsShare);
 * }
 * 
 * // Stopper le share pour libÃ©rer de la RAM
 * ns.kill("/hack/workers/share.js", "pserv-0");
 * 
 * PERFORMANCES :
 * --------------
 * RAM : 4.00 GB par thread (le plus cher des 4 workers)
 * CPU : Faible (opÃ©ration gÃ©rÃ©e par le jeu)
 * DurÃ©e : Infinie (jusqu'Ã  kill manuel)
 * 
 * PROMETHEUS OPTIMISATIONS :
 * --------------------------
 * âœ“ Validation du dÃ©lai (Ã©vite valeurs invalides)
 * âœ“ Try/catch autour de ns.share() (gestion erreurs)
 * âœ“ Logs clairs pour monitoring
 * âœ“ Support du dÃ©lai pour synchronisation
 * âœ“ Documentation exhaustive pour usage correct
 * 
 * COMPARAISON RAM WORKERS :
 * -------------------------
 * Hack   : 1.70 GB/thread
 * Grow   : 1.75 GB/thread
 * Weaken : 1.75 GB/thread
 * Share  : 4.00 GB/thread â† Le plus cher (2.3x plus que hack)
 * 
 * D'oÃ¹ l'importance d'utiliser share uniquement sur la RAM excÃ©dentaire.
 * 
 * TIPS POUR LE SYSTÃˆME :
 * ----------------------
 * 1. Share est optionnel, pas critique
 * 2. Utiliser share uniquement sur RAM inutilisÃ©e
 * 3. Monitorer l'allocation de RAM dynamiquement
 * 4. Stopper share en prioritÃ© si besoin de RAM pour batchs
 * 5. Share peut tourner en parallÃ¨le des batchs HWGW
 * 6. Pas besoin de synchronisation avec HWGW (indÃ©pendant)
 * 
 * RATIO RAM SYSTÃˆME TYPIQUE :
 * ----------------------------
 * En mid/late game :
 * - HWGW (hack/grow/weaken) : 80-90% de la RAM totale
 * - Share : 10-20% de la RAM totale (sur excÃ©dent)
 * 
 * En early game (peu de cibles rentables) :
 * - HWGW : 30-50% de la RAM
 * - Share : 50-70% de la RAM (plus utilisÃ©)
 * 
 * INTÃ‰GRATION AVEC ORCHESTRATOR :
 * --------------------------------
 * L'orchestrator peut gÃ©rer le share dynamiquement :
 * 1. Calculer RAM nÃ©cessaire pour batchs
 * 2. Allouer le reste Ã  share
 * 3. Ajuster pÃ©riodiquement (ex: toutes les 60s)
 * 4. Stopper share si besoin urgent de RAM
 * 
 * Pseudo-code :
 *   ramForBatches = calculateBatchesRamNeeded()
 *   ramAvailable = getTotalRam() - ramForBatches
 *   threadsShare = floor(ramAvailable / 4.0)
 *   
 *   if (threadsShare > currentShareThreads) {
 *       // Augmenter share
 *       launchMoreShare(threadsShare - currentShareThreads)
 *   } else if (threadsShare < currentShareThreads) {
 *       // RÃ©duire share (kill scripts)
 *       killSomeShare(currentShareThreads - threadsShare)
 *   }
 */
