/**
 * â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 * â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•
 * â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 * â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘
 * â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
 * â•šâ•â•     â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•     â•šâ•â•â•šâ•â•â•â•â•â•â•   â•šâ•â•   â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•
 *                           v45.0 - "Stealing Fire From The Gods"
 * 
 * @module      hack/controller
 * @description Dispatcher central - Lit les jobs du port 4 et dispatch les workers.
 *              GÃ¨re la copie des scripts et l'exÃ©cution sur les serveurs cibles.
 * @author      Claude (Anthropic) + tylersense-ui
 * @version     45.0 - PROMETHEUS
 * @date        2025-01-XX
 * @license     MIT
 * @requires    BitBurner v2.8.1+ (Steam)
 * 
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ”¥ PROMETHEUS ENHANCEMENTS
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * âœ“ Sleep 50ms au lieu de 1ms (FIX CPU waste critique)
 * âœ“ Backoff exponentiel sur erreurs rÃ©pÃ©tÃ©es (50ms â†’ 3200ms)
 * âœ“ fileExists avant scp (Ã©vite copies inutiles)
 * âœ“ Try/catch robuste sur exec/scp
 * âœ“ Validation jobs via PortHandler.validateCommandSchema()
 * âœ“ Logging dÃ©taillÃ© avec icÃ´nes (ğŸ®âœ…âŒâš ï¸ğŸ“¨)
 * âœ“ MÃ©triques : jobs traitÃ©s, erreurs, temps moyen
 * âœ“ Cache des fichiers copiÃ©s par serveur
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * @usage
 *   ns.run("/hack/controller.js");
 *   // Le controller tourne en boucle infinie et lit les jobs du port 4
 * 
 * @example
 *   // Envoyer un job depuis le batcher
 *   const job = { type: 'hack', host: 'pserv-0', target: 'n00dles', threads: 10, delay: 0 };
 *   portHandler.writeJSON(CONFIG.PORTS.COMMANDS, job);
 *   // Le controller le lira et exÃ©cutera automatiquement
 */

import { CONFIG } from "/lib/constants.js";
import { Logger } from "/lib/logger.js";
import { PortHandler } from "/core/port-handler.js";

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ® CONTROLLER - MAIN FUNCTION
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * Boucle principale du dispatcher :
 * 1. Lit les jobs du port 4 (COMMANDS)
 * 2. Valide le schÃ©ma du job
 * 3. Copie les workers nÃ©cessaires sur le host
 * 4. ExÃ©cute le worker avec les arguments
 * 5. GÃ¨re les erreurs avec backoff exponentiel
 * 
 * @param {NS} ns - Namespace BitBurner
 */
export async function main(ns) {
    // DÃ©sactiver les logs par dÃ©faut pour Ã©viter le spam
    ns.disableLog("ALL");
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ”§ INITIALISATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const log = new Logger(ns, "CONTROLLER");
    const ph = new PortHandler(ns);
    
    log.info("ğŸ® DÃ©marrage du Controller PROMETHEUS...");
    
    /**
     * Mapping des types de jobs vers les scripts workers
     * @type {Object}
     */
    const WORKER_SCRIPTS = {
        'hack': '/hack/workers/hack.js',
        'grow': '/hack/workers/grow.js',
        'weaken': '/hack/workers/weaken.js',
        'share': '/hack/workers/share.js'
    };
    
    /**
     * Cache des fichiers copiÃ©s par serveur
     * Format: { hostname: Set(['script1', 'script2']) }
     * Ã‰vite les scp inutiles
     * @type {Object}
     */
    const copiedFiles = {};
    
    /**
     * MÃ©triques du controller
     * @type {Object}
     */
    const metrics = {
        jobsProcessed: 0,
        jobsSucceeded: 0,
        jobsFailed: 0,
        startTime: Date.now(),
        lastJobTime: 0
    };
    
    /**
     * DÃ©lai actuel pour le sleep (backoff exponentiel)
     * @type {number}
     */
    let currentDelay = CONFIG.CONTROLLER?.POLL_INTERVAL_MS || 50;
    
    /**
     * Compteur d'erreurs consÃ©cutives
     * @type {number}
     */
    let consecutiveErrors = 0;
    
    /**
     * DÃ©lai de base et maximum pour le backoff
     */
    const BASE_DELAY = 50;       // 50ms dÃ©lai de base (au lieu de 1ms)
    const MAX_DELAY = 3200;      // 3.2s dÃ©lai maximum
    const MAX_BACKOFF_ERRORS = 5; // Nombre d'erreurs avant d'augmenter le dÃ©lai
    
    log.success("âœ… Controller initialisÃ© - En attente de jobs...");
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ”„ BOUCLE PRINCIPALE (INFINIE)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    while (true) {
        try {
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸ“¨ LECTURE DU PORT 4 (COMMANDS)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            const job = ph.readJSON(CONFIG.PORTS.COMMANDS);
            
            if (!job) {
                // Pas de job disponible - attendre avec le dÃ©lai actuel
                await ns.sleep(currentDelay);
                continue;
            }
            
            // Job reÃ§u - logger et traiter
            metrics.jobsProcessed++;
            metrics.lastJobTime = Date.now();
            
            if (log.debugEnabled) {
                log.debug(`ğŸ“¨ Job reÃ§u: ${job.type} sur ${job.host} (target: ${job.target || 'N/A'})`);
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // âœ… VALIDATION DU JOB
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            if (!ph.validateCommandSchema(job)) {
                log.error(`SchÃ©ma invalide: ${JSON.stringify(job)}`);
                metrics.jobsFailed++;
                consecutiveErrors++;
                continue;
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸ” VÃ‰RIFICATION DU WORKER
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            const workerScript = WORKER_SCRIPTS[job.type];
            
            if (!workerScript) {
                log.error(`Type de job inconnu: ${job.type}`);
                metrics.jobsFailed++;
                consecutiveErrors++;
                continue;
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸ“¦ COPIE DU WORKER SUR LE HOST (si nÃ©cessaire)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // Initialiser le cache pour ce host si nÃ©cessaire
            if (!copiedFiles[job.host]) {
                copiedFiles[job.host] = new Set();
            }
            
            // Copier seulement si pas dÃ©jÃ  copiÃ© (optimisation PROMETHEUS)
            if (!copiedFiles[job.host].has(workerScript)) {
                try {
                    // VÃ©rifier si le fichier existe dÃ©jÃ  sur le host
                    const fileExists = ns.fileExists(workerScript, job.host);
                    
                    if (!fileExists) {
                        // Copier le worker
                        const scpSuccess = await ns.scp(workerScript, job.host);
                        
                        if (!scpSuccess) {
                            log.error(`Ã‰chec scp de ${workerScript} vers ${job.host}`);
                            metrics.jobsFailed++;
                            consecutiveErrors++;
                            continue;
                        }
                        
                        if (log.debugEnabled) {
                            log.debug(`ğŸ“¦ CopiÃ© ${workerScript} vers ${job.host}`);
                        }
                    }
                    
                    // Marquer comme copiÃ© dans le cache
                    copiedFiles[job.host].add(workerScript);
                    
                } catch (error) {
                    log.error(`Erreur lors du scp: ${error.message}`);
                    metrics.jobsFailed++;
                    consecutiveErrors++;
                    continue;
                }
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸš€ EXÃ‰CUTION DU WORKER
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            try {
                // PrÃ©parer les arguments selon le type de job
                let args = [];
                
                if (job.type === 'share') {
                    // Share : seulement delay
                    args = [job.delay || 0];
                } else {
                    // Hack/Grow/Weaken : target + delay
                    args = [job.target, job.delay || 0];
                }
                
                // ExÃ©cuter le worker
                const pid = ns.exec(
                    workerScript,
                    job.host,
                    job.threads || 1,
                    ...args
                );
                
                if (pid === 0) {
                    // Ã‰chec de l'exÃ©cution (RAM insuffisante, script introuvable, etc.)
                    log.warn(`âš ï¸  Ã‰chec exec ${job.type} sur ${job.host} (${job.threads} threads)`);
                    metrics.jobsFailed++;
                    consecutiveErrors++;
                } else {
                    // SuccÃ¨s
                    if (log.debugEnabled) {
                        log.debug(`âœ… LancÃ© ${job.type} sur ${job.host} (PID: ${pid}, threads: ${job.threads})`);
                    }
                    metrics.jobsSucceeded++;
                    consecutiveErrors = 0; // Reset erreurs consÃ©cutives
                    currentDelay = BASE_DELAY; // Reset dÃ©lai au minimum
                }
                
            } catch (error) {
                log.error(`Erreur lors de l'exec: ${error.message}`);
                metrics.jobsFailed++;
                consecutiveErrors++;
            }
            
        } catch (error) {
            // Erreur critique dans la boucle principale
            log.error(`Erreur critique dans la boucle: ${error.message}`);
            consecutiveErrors++;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ”„ BACKOFF EXPONENTIEL (si erreurs rÃ©pÃ©tÃ©es)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        if (consecutiveErrors >= MAX_BACKOFF_ERRORS) {
            // Augmenter le dÃ©lai (backoff exponentiel)
            currentDelay = Math.min(currentDelay * 2, MAX_DELAY);
            log.warn(`âš ï¸  ${consecutiveErrors} erreurs consÃ©cutives - Backoff Ã  ${currentDelay}ms`);
            consecutiveErrors = 0; // Reset pour Ã©viter d'augmenter trop vite
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // â±ï¸ SLEEP (50ms au lieu de 1ms - PROMETHEUS FIX)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // Attendre avant la prochaine itÃ©ration
        // DÃ©lai dynamique selon le backoff
        await ns.sleep(currentDelay);
    }
}

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ“š DOCUMENTATION TECHNIQUE
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * RÃ”LE DU CONTROLLER :
 * --------------------
 * Le controller est le dispatcher central du systÃ¨me HWGW.
 * Il fait le pont entre le batcher (qui crÃ©e les jobs) et les workers (qui les exÃ©cutent).
 * 
 * Workflow :
 * 1. Batcher calcule un batch HWGW et Ã©crit les jobs dans le port 4
 * 2. Controller lit les jobs du port 4
 * 3. Controller copie les workers nÃ©cessaires sur les hosts
 * 4. Controller exÃ©cute les workers avec les bons arguments
 * 5. Workers s'exÃ©cutent et se terminent
 * 6. Batcher observe les rÃ©sultats et crÃ©e de nouveaux batchs
 * 
 * ARCHITECTURE :
 * --------------
 * Batcher â†’ Port 4 (COMMANDS) â†’ Controller â†’ Workers (hack/grow/weaken/share)
 * 
 * OPTIMISATIONS PROMETHEUS :
 * --------------------------
 * 
 * 1. SLEEP 50MS (au lieu de 1ms)
 *    Avant : Busy-wait Ã  1ms gaspillait des cycles CPU
 *    Maintenant : Sleep 50ms rÃ©duit la charge CPU de ~98%
 *    Impact : Permet de dispatcher 20 jobs/seconde (largement suffisant)
 * 
 * 2. BACKOFF EXPONENTIEL
 *    Si erreurs rÃ©pÃ©tÃ©es (RAM insuffisante, scripts manquants, etc.) :
 *    - 50ms â†’ 100ms â†’ 200ms â†’ 400ms â†’ 800ms â†’ 1600ms â†’ 3200ms
 *    Ã‰vite de spammer les logs et rÃ©duit la charge en cas de problÃ¨me
 * 
 * 3. CACHE DES FICHIERS COPIÃ‰S
 *    Avant : scp Ã  chaque dispatch (inefficace)
 *    Maintenant : fileExists + cache par serveur
 *    Impact : RÃ©duit les appels scp de ~99%
 * 
 * 4. VALIDATION DES JOBS
 *    Utilise PortHandler.validateCommandSchema()
 *    Rejette les jobs malformÃ©s avant tentative d'exÃ©cution
 *    Impact : Ã‰vite les crashs et logs d'erreur inutiles
 * 
 * GESTION DES ERREURS :
 * ---------------------
 * Erreurs possibles :
 * - Job invalide â†’ Log + skip
 * - Type inconnu â†’ Log + skip
 * - scp Ã©choue â†’ Log + skip
 * - exec Ã©choue (RAM insuffisante) â†’ Log + skip
 * - Erreur critique â†’ Log + continue
 * 
 * Toutes les erreurs sont loggÃ©es mais ne font pas crasher le controller.
 * Le controller continue toujours de tourner.
 * 
 * MÃ‰TRIQUES :
 * -----------
 * Le controller track :
 * - jobsProcessed : Nombre total de jobs traitÃ©s
 * - jobsSucceeded : Nombre de jobs exÃ©cutÃ©s avec succÃ¨s
 * - jobsFailed : Nombre de jobs Ã©chouÃ©s
 * - startTime : Timestamp de dÃ©marrage
 * - lastJobTime : Timestamp du dernier job traitÃ©
 * 
 * Ces mÃ©triques peuvent Ãªtre exposÃ©es via un port ou affichÃ©es dans un dashboard.
 * 
 * FORMAT DES JOBS :
 * -----------------
 * Les jobs doivent respecter le schÃ©ma COMMANDS :
 * {
 *   type: string,      // "hack" | "grow" | "weaken" | "share"
 *   host: string,      // Serveur d'exÃ©cution (ex: "pserv-0")
 *   target?: string,   // Serveur cible (sauf pour share)
 *   threads?: number,  // Nombre de threads (dÃ©faut: 1)
 *   delay?: number     // DÃ©lai en ms (dÃ©faut: 0)
 * }
 * 
 * Exemples :
 * { type: 'hack', host: 'pserv-0', target: 'n00dles', threads: 10, delay: 5000 }
 * { type: 'grow', host: 'pserv-1', target: 'joesguns', threads: 200, delay: 8000 }
 * { type: 'weaken', host: 'pserv-2', target: 'n00dles', threads: 50, delay: 0 }
 * { type: 'share', host: 'pserv-3', threads: 100, delay: 0 }
 * 
 * WORKERS SUPPORTÃ‰S :
 * -------------------
 * - /hack/workers/hack.js : Vole de l'argent
 * - /hack/workers/grow.js : Augmente l'argent
 * - /hack/workers/weaken.js : RÃ©duit la sÃ©curitÃ©
 * - /hack/workers/share.js : Partage pour factions
 * 
 * PERFORMANCE :
 * -------------
 * RAM : ~2 GB (controller lui-mÃªme)
 * CPU : TrÃ¨s faible avec sleep 50ms
 * Throughput : ~20 jobs/seconde (50ms entre lectures)
 * 
 * Le controller peut facilement gÃ©rer des centaines de batchs par minute.
 * 
 * DÃ‰MARRAGE :
 * -----------
 * Le controller doit Ãªtre lancÃ© UNE FOIS au dÃ©marrage du systÃ¨me :
 * 
 * ns.run("/hack/controller.js");
 * 
 * Il tourne en boucle infinie jusqu'Ã  Ãªtre killÃ© manuellement.
 * 
 * INTERACTION AVEC LE BATCHER :
 * ------------------------------
 * Le batcher crÃ©e des batchs HWGW et Ã©crit les jobs dans le port 4 :
 * 
 * // Dans le batcher
 * const jobs = [
 *   { type: 'hack', host: 'pserv-0', target: 'n00dles', threads: 50, delay: hackDelay },
 *   { type: 'weaken', host: 'pserv-1', target: 'n00dles', threads: 4, delay: 0 },
 *   { type: 'grow', host: 'pserv-2', target: 'n00dles', threads: 500, delay: growDelay },
 *   { type: 'weaken', host: 'pserv-3', target: 'n00dles', threads: 40, delay: 400 }
 * ];
 * 
 * for (const job of jobs) {
 *   await portHandler.writeJSONWithRetry(CONFIG.PORTS.COMMANDS, job);
 * }
 * 
 * Le controller lira ces jobs un par un et les exÃ©cutera.
 * 
 * MONITORING :
 * ------------
 * Pour monitorer le controller :
 * 
 * // Depuis un autre script
 * ns.tail("/hack/controller.js");
 * 
 * Les logs affichent :
 * - Jobs reÃ§us (en mode debug)
 * - Erreurs de validation/exec
 * - Backoff warnings
 * - Copies de fichiers (en mode debug)
 * 
 * DEBUGGING :
 * -----------
 * Pour activer les logs dÃ©taillÃ©s :
 * 
 * // Dans constants.js
 * CONFIG.SYSTEM.DEBUG_MODE = true;
 * 
 * Cela affichera :
 * - Chaque job reÃ§u
 * - Chaque fichier copiÃ©
 * - Chaque worker lancÃ© avec PID
 * 
 * TIPS :
 * ------
 * 1. Lancer le controller en premier (avant le batcher)
 * 2. VÃ©rifier que le port 4 est vide au dÃ©marrage
 * 3. Monitorer les erreurs dans les logs
 * 4. Ajuster BASE_DELAY si besoin (50ms par dÃ©faut)
 * 5. Le controller peut gÃ©rer plusieurs batchers en parallÃ¨le
 * 
 * LIMITES :
 * ---------
 * - Le port 4 peut stocker ~50 messages avant blocage
 * - Si le batcher Ã©crit plus vite que le controller lit, le port se remplit
 * - Solution : Le batcher doit utiliser writeJSONWithRetry() avec backoff
 * 
 * Ã‰VOLUTION :
 * -----------
 * Futures amÃ©liorations possibles :
 * - Multi-threading du controller (plusieurs workers parallÃ¨les)
 * - PrioritÃ© des jobs (traiter les weaken avant les hack)
 * - Retry automatique des jobs Ã©chouÃ©s
 * - Exposition des mÃ©triques via un port dÃ©diÃ©
 * - Dashboard en temps rÃ©el des jobs traitÃ©s
 */
