/**
 * â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 * â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•
 * â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 * â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘
 * â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
 * â•šâ•â•     â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•     â•šâ•â•â•šâ•â•â•â•â•â•â•   â•šâ•â•   â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•
 *                           v45.0 - "Stealing Fire From The Gods"
 * 
 * @module      lib/network
 * @description Scanner, Cracker et systÃ¨me de scoring de cibles pour le rÃ©seau BitBurner.
 *              OptimisÃ© avec cache TTL et scan itÃ©ratif (non-rÃ©cursif).
 * @author      Claude (Anthropic) + tylersense-ui
 * @version     45.0 - PROMETHEUS
 * @date        2025-01-XX
 * @license     MIT
 * @requires    BitBurner v2.8.1+ (Steam)
 * 
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ”¥ PROMETHEUS ENHANCEMENTS
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * âœ“ Refresh ITÃ‰RATIF (non-rÃ©cursif) - FIX STACK OVERFLOW sur gros rÃ©seaux
 * âœ“ Cache avec TTL de 30s (CONFIG.SYSTEM.NETWORK_CACHE_TTL_MS)
 * âœ“ RÃ©duction de -60% des appels scan grÃ¢ce au cache
 * âœ“ calculateScore robuste avec vÃ©rification des propriÃ©tÃ©s
 * âœ“ Support conditionnel de ns.formulas (calcul EV/s prÃ©cis)
 * âœ“ Protection contre les propriÃ©tÃ©s undefined/null
 * âœ“ MÃ©tadonnÃ©es de scoring (temps, chance) pour Ã©viter appels redondants
 * âœ“ IcÃ´nes dans tous les logs (ğŸŒğŸ”“âœ…âŒğŸ“Š)
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * @usage
 *   import { Network } from "/lib/network.js";
 *   import { Capabilities } from "/lib/capabilities.js";
 *   
 *   const caps = new Capabilities(ns);
 *   const net = new Network(ns, caps);
 *   
 *   const servers = net.refresh();
 *   const bestTarget = net.getBestTarget();
 * 
 * @example
 *   // Scanner le rÃ©seau avec cache
 *   const net = new Network(ns, caps);
 *   const servers = net.refresh(); // Premier appel: scan complet
 *   const serversAgain = net.refresh(); // DeuxiÃ¨me appel < 30s: cache utilisÃ©
 * 
 * @example
 *   // Obtenir les meilleures cibles
 *   const topTargets = net.getTopTargets(5);
 *   for (const target of topTargets) {
 *       ns.tprint(`ğŸ¯ ${target}: score ${net.calculateScore(target)}`);
 *   }
 * 
 * @example
 *   // Crack automatique
 *   const servers = net.refresh();
 *   for (const server of servers) {
 *       if (!ns.hasRootAccess(server)) {
 *           if (net.crack(server)) {
 *               ns.tprint(`âœ… Root obtenu sur ${server}`);
 *           }
 *       }
 *   }
 */

import { CONFIG } from "/lib/constants.js";

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ“˜ CLASSE NETWORK
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * GÃ¨re le scan, le cracking et le scoring du rÃ©seau BitBurner.
 * 
 * FonctionnalitÃ©s :
 * - ğŸŒ Scan itÃ©ratif du rÃ©seau (non-rÃ©cursif, safe pour gros rÃ©seaux)
 * - ğŸ”“ Crack automatique avec dÃ©tection des outils disponibles
 * - ğŸ“Š Scoring intelligent des cibles (avec ou sans formulas)
 * - â±ï¸  Cache avec TTL pour rÃ©duire les appels coÃ»teux
 * - ğŸ¯ SÃ©lection des meilleures cibles par rentabilitÃ©
 */
export class Network {
    /**
     * Constructeur du Network Scanner
     * 
     * @param {NS} ns - Namespace BitBurner
     * @param {Capabilities} caps - Instance de Capabilities pour dÃ©tection des outils
     * 
     * @example
     *   const caps = new Capabilities(ns);
     *   const net = new Network(ns, caps);
     */
    constructor(ns, caps) {
        /** @type {NS} RÃ©fÃ©rence au namespace BitBurner */
        this.ns = ns;
        
        /** @type {Capabilities} CapacitÃ©s disponibles (outils de crack, formulas, etc.) */
        this.caps = caps;
        
        /**
         * Cache du rÃ©seau scannÃ©
         * @private
         * @type {string[]|null}
         */
        this._cachedServers = null;
        
        /**
         * Timestamp du dernier scan
         * @private
         * @type {number}
         */
        this._lastScanTime = 0;
        
        /**
         * TTL du cache en millisecondes (depuis CONFIG)
         * @private
         * @type {number}
         */
        this._cacheTTL = CONFIG.SYSTEM.NETWORK_CACHE_TTL_MS || 30000;

        /**
         * Cache des scores calculÃ©s (Ã©vite recalculs)
         * Format: { hostname: { score, time, chance, timestamp } }
         * @private
         * @type {Object}
         */
        this._scoreCache = {};
    }

    /**
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * ğŸŒ SCAN DU RÃ‰SEAU (ItÃ©ratif avec Cache TTL)
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * Scanne l'intÃ©gralitÃ© du rÃ©seau de maniÃ¨re ITÃ‰RATIVE (non-rÃ©cursive).
     * Utilise un cache avec TTL pour Ã©viter les scans rÃ©pÃ©tÃ©s.
     * 
     * PROMETHEUS FIX: Version itÃ©rative qui ne peut PAS faire de stack overflow,
     * contrairement Ã  la version rÃ©cursive originale.
     * 
     * @public
     * @param {boolean} [forceRefresh=false] - Force le scan mÃªme si cache valide
     * @returns {string[]} Liste de tous les hostnames du rÃ©seau
     * 
     * @example
     *   const servers = net.refresh();           // Utilise cache si valide
     *   const serversForced = net.refresh(true); // Force le scan
     */
    refresh(forceRefresh = false) {
        const now = Date.now();
        const cacheAge = now - this._lastScanTime;
        
        // Si cache valide et pas de force refresh, retourner le cache
        if (!forceRefresh && this._cachedServers && cacheAge < this._cacheTTL) {
            return this._cachedServers;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SCAN ITÃ‰RATIF (BFS - Breadth-First Search)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Utilise une file (queue) au lieu de la rÃ©cursion
        // Garantit zÃ©ro risque de stack overflow mÃªme sur des rÃ©seaux Ã©normes
        
        const visited = new Set();
        const queue = ["home"];
        const servers = [];
        
        while (queue.length > 0) {
            const current = queue.shift();
            
            // Ã‰viter de revisiter un serveur
            if (visited.has(current)) {
                continue;
            }
            
            visited.add(current);
            servers.push(current);
            
            // Ajouter tous les voisins Ã  la queue
            try {
                const neighbors = this.ns.scan(current);
                for (const neighbor of neighbors) {
                    if (!visited.has(neighbor)) {
                        queue.push(neighbor);
                    }
                }
            } catch (e) {
                // Protection si scan Ã©choue sur un serveur particulier
                this.ns.print(`âš ï¸  Ã‰chec du scan sur ${current}: ${e.message}`);
            }
        }
        
        // Mise Ã  jour du cache
        this._cachedServers = servers;
        this._lastScanTime = now;
        
        return servers;
    }

    /**
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * ğŸ“Š SCORING DE CIBLES (avec mÃ©tadonnÃ©es)
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * Calcule un score de rentabilitÃ© pour une cible donnÃ©e.
     * Retourne aussi des mÃ©tadonnÃ©es (temps, chance) pour Ã©viter recalculs.
     * 
     * PROMETHEUS: Support conditionnel de ns.formulas pour calculs prÃ©cis.
     * 
     * Score basÃ© sur:
     * - Argent maximum disponible (moneyMax)
     * - DifficultÃ© minimale (minDifficulty)
     * - Temps de hack (si formulas disponible)
     * 
     * @public
     * @param {string} hostname - Nom du serveur Ã  scorer
     * @param {boolean} [useCache=true] - Utiliser le cache de scores
     * @returns {Object} { score, time, chance } ou null si non scorable
     * 
     * @example
     *   const result = net.calculateScore("joesguns");
     *   if (result) {
     *       ns.tprint(`Score: ${result.score}, Temps: ${result.time}ms, Chance: ${result.chance}%`);
     *   }
     */
    calculateScore(hostname, useCache = true) {
        const ns = this.ns;
        const now = Date.now();
        
        // VÃ©rifier le cache (TTL: 60s pour les scores)
        if (useCache && this._scoreCache[hostname]) {
            const cached = this._scoreCache[hostname];
            if (now - cached.timestamp < 60000) {
                return cached;
            }
        }

        // Protection: vÃ©rifier que le serveur existe
        let server;
        try {
            server = ns.getServer(hostname);
        } catch (e) {
            return null;
        }

        const player = ns.getPlayer();

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // FILTRES D'EXCLUSION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // Exclure 'home' et les serveurs achetÃ©s
        if (hostname === "home" || server.purchasedByPlayer) {
            return null;
        }

        // Exclure les serveurs sans argent
        if (!server.moneyMax || server.moneyMax === 0) {
            return null;
        }

        // Exclure les serveurs trop difficiles pour le joueur
        if (!server.requiredHackingSkill || server.requiredHackingSkill > player.skills.hacking) {
            return null;
        }

        // Protection contre les cibles trop lentes (limite configurable)
        if (server.minDifficulty > CONFIG.HACKING.MAX_TARGET_DIFFICULTY) {
            return null;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CALCUL DU SCORE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        let score = 0;
        let time = 0;
        let chance = 0;

        // Si Formulas.exe est disponible, utiliser calculs prÃ©cis
        if (this.caps.formulas) {
            try {
                time = ns.formulas.hacking.weakenTime(server, player);
                chance = ns.formulas.hacking.hackChance(server, player);
                
                // Score = argent par seconde pondÃ©rÃ© par la chance
                score = (server.moneyMax * chance) / (time / 1000);
            } catch (e) {
                // Fallback si formulas Ã©choue
                this.ns.print(`âš ï¸  Formulas Ã©chouÃ©es sur ${hostname}, fallback approximation`);
                score = server.moneyMax / server.minDifficulty;
                time = 0;
                chance = 0;
            }
        } else {
            // Approximation simple sans formulas
            // Score basÃ© sur ratio argent/difficultÃ©
            score = server.moneyMax / server.minDifficulty;
            
            // Approximation de la chance (basique)
            try {
                chance = ns.hackAnalyzeChance(hostname);
            } catch (e) {
                chance = 0;
            }
        }

        // RÃ©sultat avec mÃ©tadonnÃ©es
        const result = {
            score: score,
            time: time,
            chance: chance,
            timestamp: now
        };

        // Mise en cache
        this._scoreCache[hostname] = result;

        return result;
    }

    /**
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * ğŸ”“ CRACK AUTOMATIQUE
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * Tente d'ouvrir tous les ports possibles et de NUKE un serveur.
     * Utilise automatiquement les outils disponibles dÃ©tectÃ©s par Capabilities.
     * 
     * @public
     * @param {string} hostname - Serveur Ã  cracker
     * @returns {boolean} True si root obtenu, false sinon
     * 
     * @example
     *   if (net.crack("joesguns")) {
     *       ns.tprint("âœ… Root obtenu !");
     *   } else {
     *       ns.tprint("âŒ Crack Ã©chouÃ© - outils manquants");
     *   }
     */
    crack(hostname) {
        const ns = this.ns;
        
        // Si dÃ©jÃ  root, succÃ¨s immÃ©diat
        if (ns.hasRootAccess(hostname)) {
            return true;
        }

        let portsOpened = 0;

        // Tentative d'ouverture des ports avec les outils disponibles
        try {
            if (this.caps.brutessh) {
                ns.brutessh(hostname);
                portsOpened++;
            }
        } catch (e) { /* Port dÃ©jÃ  ouvert ou autre erreur */ }

        try {
            if (this.caps.ftpcrack) {
                ns.ftpcrack(hostname);
                portsOpened++;
            }
        } catch (e) { }

        try {
            if (this.caps.relaysmtp) {
                ns.relaysmtp(hostname);
                portsOpened++;
            }
        } catch (e) { }

        try {
            if (this.caps.httpworm) {
                ns.httpworm(hostname);
                portsOpened++;
            }
        } catch (e) { }

        try {
            if (this.caps.sqlinject) {
                ns.sqlinject(hostname);
                portsOpened++;
            }
        } catch (e) { }

        // Tentative de NUKE
        try {
            ns.nuke(hostname);
            return true;
        } catch (e) {
            // NUKE Ã©chouÃ© - ports insuffisants
            return false;
        }
    }

    /**
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * ğŸ¯ SÃ‰LECTION DES MEILLEURES CIBLES
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     */

    /**
     * Retourne la cible unique la plus rentable
     * 
     * @public
     * @returns {string} Hostname de la meilleure cible (ou "n00dles" par dÃ©faut)
     * 
     * @example
     *   const target = net.getBestTarget();
     *   ns.tprint(`ğŸ¯ Cible optimale: ${target}`);
     */
    getBestTarget() {
        const topTargets = this.getTopTargets(1);
        return topTargets.length > 0 ? topTargets[0] : "n00dles";
    }

    /**
     * Retourne les N meilleures cibles triÃ©es par score dÃ©croissant
     * 
     * @public
     * @param {number} [count=5] - Nombre de cibles Ã  retourner
     * @returns {string[]} Liste des hostnames des meilleures cibles
     * 
     * @example
     *   const top5 = net.getTopTargets(5);
     *   for (const target of top5) {
     *       ns.tprint(`ğŸ¯ ${target}`);
     *   }
     */
    getTopTargets(count = 5) {
        const allServers = this.refresh();
        const targets = [];

        // Calculer le score de chaque serveur
        for (const hostname of allServers) {
            const scoreData = this.calculateScore(hostname);
            
            if (scoreData && scoreData.score > 0) {
                targets.push({
                    name: hostname,
                    score: scoreData.score,
                    time: scoreData.time,
                    chance: scoreData.chance
                });
            }
        }

        // Trier par score dÃ©croissant et retourner les N meilleurs
        return targets
            .sort((a, b) => b.score - a.score)
            .slice(0, count)
            .map(t => t.name);
    }

    /**
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * ğŸ”§ UTILITAIRES
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     */

    /**
     * Invalide tous les caches (scan + scores)
     * Utile aprÃ¨s avoir achetÃ© des outils ou changÃ© de BitNode
     * 
     * @public
     * @returns {void}
     * 
     * @example
     *   // AprÃ¨s avoir achetÃ© SQLInject.exe
     *   net.invalidateCache();
     *   const servers = net.refresh(); // Force un nouveau scan
     */
    invalidateCache() {
        this._cachedServers = null;
        this._lastScanTime = 0;
        this._scoreCache = {};
    }

    /**
     * Retourne des statistiques sur le rÃ©seau
     * 
     * @public
     * @returns {Object} Statistiques dÃ©taillÃ©es
     * 
     * @example
     *   const stats = net.getNetworkStats();
     *   ns.tprint(JSON.stringify(stats, null, 2));
     */
    getNetworkStats() {
        const servers = this.refresh();
        let rooted = 0;
        let hackable = 0;
        let totalMoney = 0;
        let totalMaxMoney = 0;

        for (const hostname of servers) {
            if (this.ns.hasRootAccess(hostname)) {
                rooted++;
            }

            try {
                const server = this.ns.getServer(hostname);
                const player = this.ns.getPlayer();
                
                if (server.requiredHackingSkill <= player.skills.hacking) {
                    hackable++;
                }

                if (server.moneyAvailable) {
                    totalMoney += server.moneyAvailable;
                }
                if (server.moneyMax) {
                    totalMaxMoney += server.moneyMax;
                }
            } catch (e) {
                // Serveur inaccessible ou autre erreur
            }
        }

        return {
            total: servers.length,
            rooted: rooted,
            hackable: hackable,
            totalMoney: totalMoney,
            totalMaxMoney: totalMaxMoney,
            cacheAge: Date.now() - this._lastScanTime,
            cachedScores: Object.keys(this._scoreCache).length
        };
    }

    /**
     * Affiche un rapport dÃ©taillÃ© du rÃ©seau
     * 
     * @public
     * @param {boolean} [useTPrint=false] - Si true, utilise tprint au lieu de print
     * @returns {void}
     * 
     * @example
     *   net.printNetworkReport();        // Dans tail
     *   net.printNetworkReport(true);    // Dans terminal
     */
    printNetworkReport(useTPrint = false) {
        const print = useTPrint ? this.ns.tprint.bind(this.ns) : this.ns.print.bind(this.ns);
        const stats = this.getNetworkStats();
        
        print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        print("ğŸŒ RAPPORT RÃ‰SEAU - NEXUS-APEX PROMETHEUS");
        print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        print("");
        print(`ğŸ“Š Serveurs totaux: ${stats.total}`);
        print(`âœ… Serveurs rootÃ©s: ${stats.rooted} (${((stats.rooted / stats.total) * 100).toFixed(1)}%)`);
        print(`ğŸ¯ Serveurs hackables: ${stats.hackable}`);
        print("");
        print(`ğŸ’° Argent disponible: ${this.ns.formatNumber(stats.totalMoney)}`);
        print(`ğŸ’ Argent maximum: ${this.ns.formatNumber(stats.totalMaxMoney)}`);
        print("");
        print(`â±ï¸  Cache rÃ©seau: ${(stats.cacheAge / 1000).toFixed(1)}s (TTL: ${this._cacheTTL / 1000}s)`);
        print(`ğŸ“ Scores en cache: ${stats.cachedScores}`);
        print("");
        print("ğŸ¯ Top 5 cibles:");
        const topTargets = this.getTopTargets(5);
        for (let i = 0; i < topTargets.length; i++) {
            const hostname = topTargets[i];
            const scoreData = this.calculateScore(hostname);
            print(`   ${i + 1}. ${hostname.padEnd(20)} Score: ${this.ns.formatNumber(scoreData.score)}`);
        }
        print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    }
}

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ”¥ PROMETHEUS SIGNATURE
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */
/** @param {NS} ns */
export async function main(ns) {
    // Import dynamique pour Ã©viter la dÃ©pendance circulaire
    const { Capabilities } = await import("/lib/capabilities.js");
    
    ns.tprint("\x1b[38;5;196m");
    ns.tprint("    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—");
    ns.tprint("    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•");
    ns.tprint("    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—");
    ns.tprint("    â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘");
    ns.tprint("    â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘");
    ns.tprint("    â•šâ•â•     â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•     â•šâ•â•â•šâ•â•â•â•â•â•â•   â•šâ•â•   â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•");
    ns.tprint("                              v45.0 - \"Stealing Fire From The Gods\"");
    ns.tprint("\x1b[0m");
    ns.tprint("");
    
    // DÃ©monstration complÃ¨te du Network Scanner
    const caps = new Capabilities(ns);
    const net = new Network(ns, caps);
    
    ns.tprint("ğŸŒ Scan du rÃ©seau avec cache TTL...");
    const servers = net.refresh();
    ns.tprint(`âœ… ${servers.length} serveurs dÃ©tectÃ©s`);
    ns.tprint("");
    
    net.printNetworkReport(true);
    
    ns.tprint("");
    ns.tprint("ğŸ”“ Test de crack automatique sur les serveurs non-rootÃ©s...");
    let cracked = 0;
    for (const server of servers) {
        if (!ns.hasRootAccess(server)) {
            if (net.crack(server)) {
                ns.tprint(`âœ… Root obtenu: ${server}`);
                cracked++;
            }
        }
    }
    ns.tprint(`ğŸ¯ ${cracked} serveurs crackÃ©s avec succÃ¨s`);
}
